## 编译

JavaScript是编译语言。它不是提前编译，而是实时编译。

编译过程：

1. 分词/词法分析（Tokenizing/Lexing）
2. 解析语法（Parsing）
3. 生成机器代码

以上只是大概步骤，JS的处理要比上述复杂得多。

## 引擎

引擎负责执行

## 编译器

编译器负责翻译，将代码转换为机器码

## 作用域

作用域负责维护变量

## 变量查询

### LHS

变量的左查询是找到变量然后进行赋值。

### RHS

变量的右查询是查找到变量后进行读取。

### 为什么要区分LHS与RHS？

当RHS寻找变量的值时，如果没有找到，则抛出ReferenceError。引用错误是指找不到变量的值。

当LHS寻找变量时，如果在全局变量下没有找到，非严格模式下会自动创建该变量，严格模式下则会抛出ReferenceError。

## 词法作用域

作用域主要有两种管理模型：1.词法作用域；2.动态作用域；

词法作用域是由你所写的代码结构所决定的。例如，函数可以访问外层变量，而函数外不能访问函数内部变量。

词法作用域在引擎执行前就已经确定了。

### 欺骗词法作用域

#### eval

eval(str)接收一个js代码字符串并执行。

eval函数在严格模式下有自己的作用域。

#### with

with用于批量修改对象属性

```javascript
var obj = {
    a:1,
    b:2,
    c:3
}
// 修改obj属性的值
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 使用width修改
with (obj) {
    a = 2;
    b = 3;
    c = 4;
}
```

with语句使用的变量查询是LHS。这也就意味着在全局作用域没有找到对象时，非严格模式下会自动创建obj，从而导致内存泄漏。

with依据传递的对象创建一个全新的语法作用域。也就是说，with在内部创建了一个新的语法作用域，这个语法作用域没有obj.a等属性的值，但是上一层有，从而修改了上一层的obj对象。

避免在程序运行时修改已经确定的语法作用域。因为这会让JS引擎对语法作用域的优化手段无法生效。



## 函数作用域

可以将函数作用域理解为它是词法作用域的组成。

函数有单独的作用域，函数内部的变量是封闭的，外部无法访问。

## 块级作用域

块级作用域可以简单理解为{...}内就是一个块级作用域。

var关键字声明的变量不是块级作用域；

let、const关键字声明的变量为块级作用域；





